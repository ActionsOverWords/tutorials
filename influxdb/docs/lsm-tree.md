# LSM-tree (Log-Structured Merge-Tree)

## LSM Tree란?
- 쓰기 작업에 최적화된 데이터 저장 구조
- 데이터 삽입이 빈번한 시스템에 적합
- 데이터를 순차적(sequential)으로 디스크에 기록함으로써 쓰기 성능을 극대화

## 작동 방식

### 1. 메모리 컴포넌트(MemTable)
- 모든 새로운 데이터는 먼저 메모리(RAM)에 저장
- 이는 디스크 접근보다 훨씬 빠르기 때문에 쓰기 성능을 크게 향상
- MemTable은 주로 정렬된 자료구조(예: 레드-블랙 트리, 스킵 리스트)를 사용하여 메모리 내에서 데이터를 정렬된 상태로 유지

### 2. 디스크 컴포넌트(SSTable)
- MemTable의 크기가 임계치에 도달하면, 메모리의 데이터가 정렬된 상태로 디스크에 기록
- 이때 생성되는 파일이 SSTable(Sorted String Table)
- SSTable은 한 번 기록되면 변경되지 않는 불변(immutable) 속성을 가짐

### 3. 컴팩션 (Compaction)
- LSM-tree의 핵심은 컴팩션(compaction) 또는 병합(merge) 과정
- 새로운 데이터가 계속해서 SSTable로 기록되면 디스크에 수많은 SSTable이 쌓임
- 이렇게 되면 데이터를 읽을 때 여러 파일을 검색해야 하므로 읽기 성능 저하
- 이를 해결하기 위해 백그라운드에서 주기적으로 여러 SSTable을 병합하여 새로운 하나의 더 큰 SSTable을 생성
- 이 과정에서 중복되거나 삭제된 데이터는 정리되고, 파일의 수가 줄어들어 검색 효율이 개선

## 장/단점

### 장점
- 높은 쓰기 성능: 데이터를 메모리에 먼저 저장하고, 디스크에 순차적으로 기록하기 때문에 랜덤 쓰기가 많은 B-tree보다 훨씬 빠름
- 낮은 쓰기 증폭(Write Amplification): 데이터를 디스크에 한 번만 쓰면 되는 경우가 많아 디스크 수명을 늘리고 효율성을 높임
- 뛰어난 압축 효율: 정렬된 상태로 저장되기 때문에 데이터 압축이 용이

### 단점
- 낮은 읽기 성능: 데이터를 찾기 위해 메모리의 MemTable과 디스크의 여러 SSTable을 모두 확인해야 할 수도 있어 읽기 작업이 느릴 수 있음
- 백그라운드 컴팩션 오버헤드: 주기적인 컴팩션 작업이 I/O 부하를 유발하여 시스템 성능에 영향을 줄 수 있음
- 데이터 파편화: 같은 키에 대한 여러 버전의 데이터가 여러 SSTable에 존재할 수 있어 저장 공간의 낭비가 발생할 수 있음.
이는 컴팩션으로 해결되지만, 컴팩션이 제때 이루어지지 않으면 문제가 될 수 있음
